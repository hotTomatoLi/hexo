---
title: 算法学习-基础-初级排序
tags: [算法学习,初级排序]
toc: true
---

# 背景
初级排序。
## 排序算法稳定性
假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的；

## 选择排序
### 算法描述
选择排序的算法如下：
- 找到最小的元素，将它与第一个元素交换位置；
- 然后在剩下的数组中找到最小的元素，与第二个元素交换位置；
- ...

遍历数据i=0...n-1：对于第i次遍历，      
a[0]...a[i]的数据已经有序，遍历a[i+1]到a[n-1]，找到最小的数据，将该数据与a[i+1] 交换。   
  

### 代码
```
    void sort(Comparable[] array) {
        for(int i = 0; i < array.length; i++){
            int index = i;
            for(int j = i+1; j < array.length; j++){
                if(!less(array[index],array[j])){
                    index = j;
                }
            }
            exch(array, i, index);
        }
    }
```
`less(x,y)`方法判断x是否小于y;`exch(array,i,j)`交换在array数组中array[i]和array[j]的位置。   


### 选择排序特点
      
- 选择排序每次交换一个元素，共N次；   
- 选择排序总共比较次数为(N-1) + (N-2) + ... + 1 = (N-1)N/2，时间复杂度为O(n2)； 
- 选择排序的运行时间与输入数组的初始状态无关，无论是否有序，都需要同样的时间复杂度；
- 交换次数与数组大小呈线性关系；
- 选择排序不是稳定的 [1 1 1 0 1 1 1]

## 插入排序

### 算法描述
插入排序算法如下：
- 对于第i个元素，其前面i-1个元素已经有序，
- 将第i个元素与其前面的j个元素依次比较，如果a[j+1] < a[j]，交换，再比较j和j-1

### 代码
```
    void sort(Comparable[] array) {
        for(int i = 1; i < array.length; i++){
            for(int j = i; j > 0 && less(array[j], array[j - 1]) ; j--){
                exch(array, j, j-1);
            }
        }
    }
```

### 插入排序特点
- 最坏情况，数组本身为倒叙，则最后一个元素，需要比较n-1次，交换n-1次；第二个元素比较1次，交换1次，时间复杂度为O(n2)