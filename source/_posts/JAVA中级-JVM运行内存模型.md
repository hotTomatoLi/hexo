---
title: JAVA中级-JVM运行内存模型
tags: [JAVA中级,JVM]
toc: true
---

注意：个人学习总结，面试准备

# 概述
在JAVA中，所有程序最终是运行在JVM（java virtual machine）中。首先经过编译器编译好的字节码文件，会经过JVM的加载、验证等步骤，最终可以实现相应的逻辑。
在JVM中，所具有的内存会划分成多个区域，不同的区域存储不同形式的数据。

# JVM运行内存
在虚拟机规范中，规定了JVM所具有的内存会划分成以下几个部分：

- 程序计数器（线程私有）
- 虚拟机栈（线程私有）
- 本地方法栈（线程私有）
- 堆
- 方法区

不同的虚拟机的具体实现方式是不一样的，尤其是**方法区**，在HotSpot1.8之前的虚拟机版本中，**方法区**是用**Permanent Generation（永久代）**实现，但是自从1.8版本后，就不再存在**永久代**的概念，取而代之的是**Metaspace（元空间）**。（在1.7版本时，原来在**永久代**的字符串常量池就已经移除，放到堆中。当**永久代**存在时，**永久代**的回收是与老年代合并在一起，这两个区域任意一个区域满了都会触发**Major GC**）。

## 程序计数器
程序计数器为线程私有，指向正在执行的字节码的指令地址（本地方法值为Undefined），同时也未定义`OutOfMemoryError`异常。

## 虚拟机栈
线程私有，虚拟机栈的生命周期与相应的线程一致。每个JAVA方法执行的时候，都会创建一个栈帧（Stack Frame），栈中存放了方法内相关的数据，在编译阶段，栈帧大小就已经确定，与运行时数据无关。
`StackOverflowError`和`OutOfMemoryError`两种错误。

## 本地方法栈
本地方法栈，是JVM使用Native方法时，即某个线程，调用了一个本地方法，那么就可以不再受虚拟机限制（通过虚拟机运行时数据；使用本地处理器中寄存器；分配内存等等）。当线程调用本地方法时，会生成本地方法对应的栈，存放到这个区域。
会有`StackOverflowError`和`OutOfMemoryError`。

## 堆
堆，一般是JAVA虚拟机管理的最大的内存，是线程共享的区域，用于存放对象实例。堆可以分为：
- 新生代
    - Eden
    - survivor * 2
- 老年代
会有`OutOfMemoryError`异常。

## 方法区
线程共享，存储被JVM加载的类信息、常量、静态变量等等，JVM规范中，方法区描述为堆的一个逻辑部分，单俗称"非堆（Non-Heap）"。HotSpot上称为永久代，但是1.8之后已经移除。会有`OutOfMemoryError`异常。
